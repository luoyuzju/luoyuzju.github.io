---
layout: post
title: Go知识点大梳理(五)并发全解
category: Go语言
keywords: Go的并发
tags: Go Go并发
---



# Go知识点大梳理（五）并发全解

## 0x00前言
#### 1.Go的并发

++并发是Go语言的强项，比如网络服务器上，同时响应成千上万个请求。在Go中，每一个并发执行的活动称为goroutine。goroutine会被调度到可用的逻辑处理器上执行。 最后注意：**并发不是绝对的同时发生，而是我们无法假设其发生的顺序。**++

#### 2.并发与并行的区别

++并发是指多线程程序在单核机器上运行，而并行是指多线程程序在多核机器上运行。++

#### 3.为什么是Go？

++Go并发提出了一个概念：不要用共享内存来通信，反过来要用通信来共享内存。++

#### 4.Go怎么使用

++Go被用来处理一段函数的逻辑，通常使用的方法如下：++
```go
go function
```

++Go的协程是由主线程(主线程消耗资源较大)上开启的，属于轻量级的“线程”，较少了上下文的切换，对资源消耗小。特点有三个：++  
1、独立的栈空间  
2、共享线程的堆空间  
3、用户调度控制  

#### 5.协程需要的注意点
**1、主线程如果完成(退出)后，不管协程是否执行完毕，同样会退出。**  
2、协程完成不会影响主线程。  
3、多核CPU的情况下，协程能够自主识别并切换并发模式/并行模式。

## 0x01Go的并发与调度
#### 1.MPG模型
Go的并发模型MPG：内核线程Machine--处理器Processor--协程Goroutine。
* Machine 

&#160;&#160;&#160;&#160;&#160;&#160;&#160;操作系统级抽象线程，操作系统管理，Go协程实际执行的地方，通常个数等于CPU核心数，一个M可以对应多个Processor，但一个时刻只能处理一个Processor。

* Processor 

&#160;&#160;&#160;&#160;&#160;&#160;&#160;逻辑处理器，提供了线程的上下文环境。P的数目决定了最大可并行的G数量。P中保管一个本地队列，保存等待执行的Goroutine。

* Goroutine 

&#160;&#160;&#160;&#160;&#160;&#160;&#160;即通过go调用的协程，它不是真正的线程，实施在编程语言层次。一个goroutine对应一个结构体，包含了40多个成员变量，包括线程状态、内核线程。

* 全局队列  

&#160;&#160;&#160;&#160;&#160;&#160;&#160;事实上还存在一个全局队列，当所有的P本地队列都存满后，协程任务将被放置到全局队列，然后等待某个P被释放或被轮询到。

![image](https://note.youdao.com/yws/api/personal/file/837E5056A02A488183DD4910F811BD4A?method=download&shareKey=3ab508e1acd5c8c5085a7b681973c2d3)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;当创建一个goroutine后，这个goroutine会被放置到调度器的全局运行队列中。之后，调度器就会给全局队列中的goroutine分配到一个逻辑处理器，并放置在该逻辑处理器的本地运行队列中，本地队列的goroutine会一直等待自己被分配的逻辑处理器执行。

&#160;&#160;&#160;&#160;&#160;&#160;&#160;通常逻辑处理器要比操作系统线程数目少，P的个数默认情况下和CPU核数一致，但可以自主设置CPU的核数，因为Go中是M:N的线程模型。
```go
//GOMAXPROCS设置可同时执行的最大CPU数，并返回先前的设置。
runtime.GOMAXPROCS(num)

//SetMaxThreads设置go程序可以使用的最大操作系统线程数
SSetMaxThreads(10000)
```

#### 2.调度策略
* 队列轮转（正常运行）

&#160;&#160;&#160;&#160;&#160;&#160;&#160;每个P都维护一个局部协程队列，处理器P依次将协程G调度到M中执行。一个G执行完后，P会调度另一个G进行执行。同时为了防止全局队列中的协程"饿死"，每个P会周期性检测全局队列并执行。（全局队列大多数是从系统调用中恢复的P）

* 系统调用（阻塞）

&#160;&#160;&#160;&#160;&#160;&#160;&#160;如果一个协程发起系统调用，那么会导致线程进入阻塞。P的局部队列协程无法调度，同样阻塞。Go的解决机制如下：  
&#160;&#160;&#160;&#160;&#160;&#160;&#160;当G进入系统调用后，M将释放G，由新的M1接管P，代替M执行剩余的协程，而M用来等待G的调用返回。 当G返回后，等待G的M有两种选择：若能获取到空的P，则获取一个P执行G；否则将G放置于全局队列中，等待被其他P调用，M休眠。

* 工作量平摊（P中的协程数不均匀）

&#160;&#160;&#160;&#160;&#160;&#160;&#160;工作量平摊解决的是不同的P中携带的待运行协程数目不一致的问题。一个逻辑处理器P闲下来后，会先去访问全局队列，若全局队列无协程，则去从一个正在运行的P中偷取一个协程的工作量，大概是一半的协程数目。

* 抢占式调度（避免协程长时间占用）

&#160;&#160;&#160;&#160;&#160;&#160;&#160;调度器会监控每个协程的执行时间，一旦执行时间过长且有其他协程在等待时，转而调度其他协程，类似于时间片轮转。

#### 4.goroutine和线程的区别
* 1、栈的大小  
os线程：每个os线程默认栈的固定大小为2MB，栈内存区域保存函数的局部变量，但固定大小的劣势太明显：有时资源浪费、有时不够用   
协程goroutine：按需增加，起始大小为2KB，最多可达到1GB。

* 2、调度者
os线程：os内核调度，每隔几毫秒都会时间片流转，停止目前的线程--->保存现场环境--->选择要执行的线程--->取出将要执行的线程环境--->执行线程。上下文切换导致os线程的开销比较大。   
协程：go自身创建了一个调度器，能够复用m个goroutine到n个os线程，达到m:n的调度算法。但go调度器不是由硬件时钟控制，而是由软件触发如阻塞、休眠、互斥量等，无需切换到内核，开销小。

* 3、GOMAXPROCS  
GOMAXPROCS参数用于设置线程OS的数量，默认值为CPU个数。正在休眠或正在被通道通信阻塞的goroutine不需要占用线程，阻塞在IO或系统调用中需要独立的os线程，但不需要计算在GOMAXPROCS内。

* 4、标识符  
os线程有标识符，goroutine没有标识符。


## 0x02并发的两种方式
并发的两种模式：一种是通过直接访问共享变量来实现不同协程间的通信，另一种是通过通道来实现通信。目的是达到并发安全。它们之间的区别在于：协程是否能够直接访问变量。若直接访问，需要使用互斥机制，若不直接访问，变量存储在通道中，通过通信去读取。  
正如Go的箴言：不要通过共享内存来通信，而要通过通信来共享内存。


#### 1.直接访问
##### 1.互斥锁
* 用通道实现互斥锁

```go
var sema = make(chan struct{}, 1) //用来保护obj的二进制信号量
var obj int = 0

fun option1() {
    sema <- struct{}{} //存入sema，其他访问的线程会阻塞
    //对obj进行操作
    <-sema //取出sema，允许其他线程访问
}

fun option2() {
    sema <- struct{}{} //不满足会阻塞等待
    //对obj进行操作
    <-sema //操作完毕，允许其他线程访问
}
```

* 互斥锁sync.Mutex  
由于互斥锁模式非常好用，Go中同样设计了sync.Mutex作为互斥锁，具体用法为进入函数第一步上锁，在临界区操作完毕后，最后解锁。go中为了防止错误情况发生但解锁不及时，配合defer可以将上锁解锁写在一起。
```go
var mtx sync.Mutex //用来保护obj的二进制信号量
var obj int = 0

fun option1() {
    mtx.Lock() //上锁操作
    defer mtx.Unlock() //解锁操作，允许其他线程访问
    //临界区：对obj进行操作
}

fun option2() {
    mtx.Lock() //上锁操作
    mtx.Unlock() //解锁操作，允许其他线程访问
    //临界区：对obj进行操作
}
```

* 读写互斥锁(多读单写锁)sync.RWMutex  
支持读操作并发运行，写操作需要完全独享的访问权限。读操作用RLock、RUnlock，写用Lock、Unlock。
```go
var RWmtx sync.RWMutex //用来保护obj的二进制信号量
var obj int = 0

fun ReadOption() {
    RWmtx.RLock() //上锁操作
    defer RWmtx.RUnlock() //解锁操作，允许其他线程访问
    //临界区：对obj进行读操作
}

fun option2() {
    RWmtx.Lock() //上锁操作
    RWmtx.Unlock() //解锁操作，允许其他线程访问
    //临界区：对obj进行写操作
}
```
只有当读场景远多于写场景时，读写锁的性能才会比互斥锁强。

> 为什么读锁也要上锁呢？  
原因有二：   
一、防止目前该操作插入到其他操作中间  
二、内存同步。CPU核中有缓存，对内存的写入是在每个CPU的缓存中执行的，这一步对goroutine不可见。而通道通信或写操作都会指引CPU把累计的操作往内存中写，导致行为对其他goroutine可见。不可见的后果是内存不同步，被编译优化后的顺序颠倒。 

* 初始化sync.Once
为了保证一次性初始化的问题，sync提供了once结构体，里面包含了一个布尔量和一个互斥锁。若函数未执行过，调用函数，将布尔量置true，否则不调用布尔量。  
```go
var loadOnce sync.Once

func Method(){
    loadOnce.Do(要调用的函数function)//保证了函数只被调用一次
    //
}
```

##### 2.原子函数sync/atomic
Go中原子函数能够以底层的加锁机制来同步访问整型变量和指针。[原子函数参考](https://blog.csdn.net/f110300641/article/details/83510081)
```go
import "sync/atomic"
atomic.AddInt64(addr, delta_num)
```

##### 3.sync.WaitGroup
WaitGroup针对的问题是，虽然管道chan大部分情况下完美地解决了通信问题，但适用面太广，同时chan也是一个解决体，占用了不必要的内存，而用WaitGroup就可以完成多个goroutine之间的同步。  
常用的WaitGroup方法如下：  
```go
import "sync"
wg := sync.WaitGroup{}
wg.Add(num) //需要同步的任务个数num

//协程
func GoroutineExample(&wg) {//地址或值作为参数传入协程，底层作优化
    //执行
    wg.Done()//计数减一，实质Add(-1)
}

//主线程等待
wg.Wait()
```
其底层原理是在WaitGroup中存储引用计数，Wait等待所有任务数完成，计数为0时才能继续，否则阻塞。

#### 2.通信管道
goroutine的另一种通信方法就是通道channel。管道的本质是一个FIFO的队列，分为有缓冲和无缓冲通道。 
* 通道的声明、发送和接收  

通道的声明需要绑定类型，一个通道只能传递一种类型的数据，牢记chan是一个引用类型，需要初始化才能使用，写入或读取一个nil管道是会导致崩溃的。   
通道只有三个操作：发送chan<-，接收<-chan，关闭close(chan)  

&#160;&#160;&#160;&#160;&#160;&#160;&#160;发送：在箭头左边为通道名，右边为写入类型的变量。函数参数可以设置为只写。
```go
func Method(chan<- int)//可写不可读
```

&#160;&#160;&#160;&#160;&#160;&#160;&#160;接收：当接收时，箭头为一元运算符，接收有两种形式，一种是取出后抛弃，另一种是取出后引用。
```go
func Method(<-chan int)//可读不可写
```

&#160;&#160;&#160;&#160;&#160;&#160;&#160;关闭：通道关闭后，不允许写入，写入会导致崩溃，虽然读取不会造成崩溃，但当读完存量元素后，读出的只能是零值。&#160;&#160;&#160;对于通道的关闭是慎之又慎的，因此必须采取方法来判断是否关闭：1、双返回值，用布尔量反映是否通道是否关闭。2、for-range访问，能识别通道是否关闭。最后，一个通道最多只能关闭一次，多次关闭相同通道会报错。

```go
//通道的声明及初始化
var IntChan chan int  // 声明一个通道，此时IntChan为nil
IntChan = make(chan int) //chan是一个引用类型，需要通过make初始化，本句初始化了一个无缓冲通道
IntChan = make(chan int, 0) //无缓冲通道，等同于上一句
IntChan = make(chan int, 10) //缓冲通道，有10个int的余量，队列长度为10

//通道的发送
IntChan<-8

//通道的接收
<-IntChan //接收方式1：接收值后丢弃
x := <-IntChan //接收方式2：接收值后交付给临时变量

//通道的关闭
close(IntChan)

在通道关闭后任何的写入都是违规的，但任何读取的操作都会得到通道类型的零值。
```
* 无缓冲通道

&#160;&#160;&#160;&#160;&#160;&#160;&#160;讲述无缓冲通道要从创建说起。
```go
tmpChan := make(chan struct{}) 或 tmpChan := make(chan struct{})
```
&#160;&#160;&#160;&#160;&#160;&#160;&#160;无缓冲通道的最大特点是同步。发送操作先手会阻塞，直到对应的通道chan上有接收操作。接收操作先手也会阻塞，直到对应的通道chan上有发送动作。发送方只有等接收方接收值后才能被再次唤醒。  
&#160;&#160;&#160;&#160;&#160;&#160;&#160;管道则是多个通道连起来的数据路径。

* 缓冲通道

&#160;&#160;&#160;&#160;&#160;&#160;&#160;缓冲通道也从创建说起。
```go
tmpChan := make(chan struct{}, 10)
```
&#160;&#160;&#160;&#160;&#160;&#160;&#160;缓冲通道最大的特点是缓冲区，具备一个人为可定长度的元素队列，实现FIFO。接收方从队头取值，发送方从队尾入值。 
&#160;&#160;&#160;&#160;&#160;&#160;&#160;如果发送和接收的频率不一致：如果缓冲区满了，则发送阻塞，直到接收方接收一个队列中的元素;如果发送区为空，则接收阻塞，直到发送方发送一个元素到队列中。

* 无缓冲通道与缓冲通道的区别

&#160;&#160;&#160;&#160;&#160;&#160;&#160;无缓冲通道和缓冲通道的选择、容量大小对程序都有直接的影响。 无缓冲通道提供强同步保障，有缓冲通道则是将发送和接收实现了解耦。

* select多路复用

&#160;&#160;&#160;&#160;&#160;&#160;&#160;select多路复用的通用形式：
```go
select{
    case <-ch1:  //从ch1能接收到值（但不用）
        //...
    case x := <-ch2://从ch2能接收到值并保存，可以在代码块中处理
        //...
    case ch3<-y: //往ch3写一个值
        //...
    default: //以上条件都不满足，目前为轮询状态，如果没有default，select会阻塞。
        //...
}
```
&#160;&#160;&#160;&#160;&#160;&#160;&#160;每一个情况指定一次通信（发送和接收）和关联的操作代码块。如果多个情况(不包括default)同时满足，则随机处理其中的一个。  
&#160;&#160;&#160;&#160;&#160;&#160;&#160;PS：如果case中操作了nil的管道，该语句会被忽略。


#### 3.竞态检测
检测竞态冲突 -race
```go
go build -race
go run -race
go test -race
```

## 0x03管道Chan底层剖析
#### 底层结构
源码包runtime/chan.go中定义了管道的数据结构，可以看到chan是一个引用类型，其实际存放元素的容器是一个循环队列。
```go
type hchan struct {
    dataqsize uint     //队列容量
    qcount uint        //剩余可用数字的个数
    buf unsafe.Pointer //循环队列指针
    elemtype *_type    //元素类型
    elemsize uint16    //元素大小
    sendx  uint        //下一个写入时的队列下标
    recvx  uint        //下一个读出时的队列下标
    sendq  waitq       //阻塞在该通道的写等待队列
    recvq  waitq       //阻塞在该通道的读等待队列
    lock   mutex       //互斥锁，chan不允许并发读写
    closed uint32      //通道状态
}
```

#### 管道的创建
管道的创建底层即初始化hchan结构，其中元素类型和循环队列长度由make函数指定，buf大小由类型大小和类型个数共同决定。

#### 管道的写入
管道写入数据时：  
1、若循环队列存在空余位置，则将数据写入循环队列，结束。  
2、若当前位置不足，将协程写入到sendq中，进入睡眠等待被唤醒。

技巧：若写入时接收队列recvq不为空，则直接传给该队列的第一个协程，减少写入循环队列再传出的损耗。

#### 管道的读取
管道读取数据时：  
1、若循环队列存在未读取的数据，则将数据从循环队列读出，结束。  
2、若循环队列内不存在未读取的数据，则将协程写入到recvq中，进入睡眠等待被唤醒。

技巧：若写入时写入队列sendq不为空，则直接从该队列的第一个协程中取值，减少写入循环队列再传出的损耗。

#### 管道的关闭
管道关闭会将recvq的协程全部唤醒，这些协程获取的值为nil,   
同时会把sendq队列的协程全部唤醒，这些协程触发panic。

## 0x04select底层
#### select特性
* 限于管道读写  
select只能作用于管道，包括数据的读取和写入。
* 返回值  
select的返回值可选为1个或2个，而第二个参数只有当读管道才能有意义。
* default  
default本意无法处理管道，只有当其他case不满足条件时，会出发default。

#### case的底层
case的底层语句对应于runtime.scase数据结构：
```go
type scase struct{
    c *hchan //case语句操作的管道地址
    kind uint16 //对该管道的操作类型
    elem unsafe.Pointer //操作该管道的另一个参数，如写管道需要一个传入的变量，读管道需要一个接收的变量
}
```
由此看出，case语句中必须并且只能携带一个管道,case中的操作必须有读或写，因此管道只有一个类型:
```go
const {
    caseNil = iota //nil管道
    caseRecv       //读管道
    caseSend       //写管道
    caseDefault    //default管道
}
```



#### 实现逻辑
管道的底层逻辑为select语句
```go
func selectgo(cas0 *scase, order0 *uint16,  ncases int)(int, bool){}
//cas0 *scase 表示传入的case数组，为显式的所有case
//order0 *uint16 表示整形数组地址，长度为ncases的两倍，前半部分用于存放访问的随机值，后半部分为加锁顺序（不展开）
//ncases int 表示显式写出来的case数目
```
整体的实现流程如下：  
1、获取cas0管道数组和order0  
2、遍历cas0的所有管道，将所有nil管道设为scase{},目的是kind设为caseNil  
3、对order0进行随机排序   
4、按order0的随机顺序for遍历cas0内的管道，根据cas的kind进行不同操作   
4.1 如果是nil，Continue   
4.2 如果是读或写操作，判断当前是否可执行：可执行则跳出for遍历并处理数据，不可执行则遍历下一个管道。  
4.3 如果有default管道存在，记录default管道的下标和值。  
5、当所有case未就绪：如果存在default，走default;否则阻塞等待所有的管道。

## 0x05并发模式（补）
#### 1、runner

#### 2、pool

#### 3、worker