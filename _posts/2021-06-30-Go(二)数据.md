---
layout: post
title: Go知识点大梳理(二)基本类型和分支
category: Go语言
keywords: Go Go基本类型
tags: Go
---

# Go知识点大梳理(二)数据

## 0x00前言
<u>Go语言的数据类型主要分为两类：一类是基本数据类型，另一类复杂数据则包括基础数据组合与引用类型。每个分类下的数据名可以参考下图。</u>

![go数据类型](https://note.youdao.com/yws/api/personal/file/2C3654744BE5430EAF2F03AC8D5C225E?method=download&shareKey=8407e59ce0efdc779b31c58f2e6d338b)

## 0x01基本数据 
#### 1.整数  
* 类型  

&#160;&#160;&#160;&#160;&#160;&#160;&#160;Go中的整数共分为四种大小，分别是8位、16位、32位和64位，根据首位标志又可分为无符号整数和有符号整数。
&#160;&#160;&#160;&#160;&#160;&#160;&#160;Go中包含了int、uint两种自适应类型，其大小会根据不同的平台自动优化成32位或64位，但依然保留int类型；除此之外，uintptr也是无符号整数，但大小未知，仅用于底层编程，完整存放指针。  
&#160;&#160;&#160;&#160;&#160;&#160;&#160;整数型自带两组同义声明，rune-int32，常用来指明一个值是Unicode码点；byte-uint8指明一个值是原始数据。

```markdown
带符号的整型 int8 int16 int32 int64
无符号的整型 uint8 uint16 uint32 uint64
自适应大小   int   uint
未知大小     uintptr（完整存放地址）
同义类型     rune-int32     byte-uint8
```


&#160;
* 操作符 

&#160;&#160;&#160;&#160;&#160;&#160;&#160;Go的整数操作符大抵和其他语言一致。这里记录一个位清空操作符&^。x&^y会让x自身在y为1的位上清0。
```go
x := 1 << 5 | 1 << 1  //00100010
y := 1 << 1           //00000010
z = x &^ y            //00100000
```
&#160;
* 左移和右移

&#160;&#160;&#160;&#160;&#160;&#160;&#160;Go中整型变量左移以0填补右边的位置，右移以符号位填补左边的位置。
&#160;
* 注意点

&#160;&#160;&#160;&#160;&#160;&#160;&#160;rune和int32不是同一个类型，即便它们所占位数是相同的，但在go中仍视作不同的类型。同理int与int32一样，所有类型名不同的变量（别名也算类型名不同），都无法直接赋值。

#### 2.浮点数  
* 类型   

&#160;&#160;&#160;&#160;&#160;&#160;&#160;Go中浮点数的类型只有float32和float64。math包给定了其最大值math.MaxFloat32与math.MaxFloat64。

* 底层位分配

&#160;&#160;&#160;&#160;&#160;&#160;&#160;在Golang中，一个Float数据由三部分组成:符号位+指数位+尾数位。Float32为符号位+指数位8+尾数位23；Float64为符号位+指数位11+尾数位52。用一个例子简单看一下如何算指数位和尾数位:
```math
10.75=2^3+2^1+2^{-1}+2^{-2}=1010.11=1.01011*2^2
```
&#160;&#160;&#160;&#160;&#160;&#160;&#160;01011表示尾数部分，2表示指数部分。
```markdown
精度类型 Float32 Float64
```

* 注意点

&#160;&#160;&#160;&#160;&#160;&#160;&#160;在运算中，应尽量使用64位避免32位带来的误差累积叠加。

#### 3.复数
* 类型

&#160;&#160;&#160;&#160;&#160;&#160;&#160;Go中的复数有两种类型，分别是complex64和complex128，它们之间的区别在于前者由两个Float32组成，后者由两个Float64组成。
&#160;
* 操作

&#160;&#160;&#160;&#160;&#160;&#160;&#160;复数创建使用内置函数complex(real_val, imag_val)，实数、虚数的提取使用内置函数real(complex_val)、imag(complex_val)。另外amth/cmplx包中提供了复数的运算库函数，如平方根和幂函数。
```go
var x complex64 = complex(1, 2) // 1 + 2i
var y complex64 = complex(3, 4) // 3 + 4i
x * y       // -5 + 10i
real(x * y) // -5
imag(x * y) // 10

cmplx.Sqrt(-1) // 0 + 1i
```

#### 4.布尔值  
* 注意点   

&#160;&#160;&#160;&#160;&#160;&#160;&#160;布尔值的概念与其他语言使用相同。Go中true和false不能直接作为1和0进行使用。它们是不同的类型。
#### 5.字符串  
* 类型   

&#160;&#160;&#160;&#160;&#160;&#160;&#160;**Golang中字符串是不可变的字节序列，不存在专用的字符类型。** 文本字符串被解读成按照**UTF-8编码**的Unicode码点序列，因此字节和字符不一定是一对一，非ASCII字符需要多个字节。
<details> 
    <summary>string常见用法</summary>   

```go  
var s string = "Hello,World." //Hello,World.称作字面量   
t := s[1:7] //使用子串不开辟新空间，共享底层数据结构
s = s + "Go!" //连结符 Hello, World. Go!

s = '/%s/     
     //'          //原生字符串字面量，忽略转义字符和格式
     
//utf-8表示
var s = "hello,世界" //实际占用13个字节，统计为8个字符
count := 0
for range s{
    count++ //最后count为8
}
```

</details>

&#160;
* 底层结构
```go
type stringStruct struct {
	str unsafe.Pointer
	len int
}
```
&#160;&#160;&#160;&#160;&#160;&#160;&#160;如底层结构所示，string的结构体中包含了一个指向字面量的指针和字串的长度，本身不开辟空间存储字符的字节。因此奠定了其具有两个特性：1、字符串允许为长度为0的空串，但不能指针为nil。2、字符串对象不可修改。

&#160;
* 效率问题

&#160;&#160;&#160;&#160;&#160;&#160;&#160;新字符串的内存空间是一次分配完成的，不可追加，因此性能消耗主要在拷贝数据上。拼接过程中，string会被暂存到byte切片中，然后第一次遍历获得长度信息以申请空间，第二次遍历实现拷贝。


* 字符串问题  

&#160;&#160;&#160;&#160;&#160;&#160;&#160;**为什么字符串不可改变？** 字符串内部的指针指向的字面量存在于内存只读区。这种不可变特性带来的优点是两个字符串能安全地使用同一段底层内存，比如使用一个长字符串的任何子串都不会带来新内存空间的消耗。  
&#160;&#160;&#160;&#160;&#160;&#160;&#160;**非ASCII码的字符如何统计字节数或修改？** 非ASCII字符可能要用多个字节表示，而字符串是以UTF-8编码为单位。如果要统计字节数，将string转换成[]byte，再遍历循环进行字节统计。如果要修改string的表达内容，通过拷贝转换为[]rune，再通过切片赋值修改。 len()计算的时字节长度，如果有非ASCII的字符存在，且计算字符长度的话，需要用[]rune。
<details> 
    <summary>代码说明</summary>   

```go  

var s = "hello,世界"
byte_slice := []byte(s)//转换为byte[]切片
count := 0
//统计字符个数
for range byte_slice {
    count++
}

rune_slice := []rune(s)
//修改rune切片内容
rune_slice[6] = '人'
fmt.Print(string(b))
```
</details>

&#160;
* 转换    

&#160;&#160;&#160;&#160;&#160;&#160;&#160;Go中常用的字串标准包：bytes,strings,strconv,unicode。strings包提供搜索、替换、切分、连接功能。bytes包将string转换为切片形式进行调整。strconv包则是将字符串转为布尔值、整数、浮点数等相互转换形式。unicode包则能判断文字符号，通常判断是否为字母、数字。

&#160;&#160;&#160;&#160;&#160;&#160;&#160;**字符串与切片的互相转换：** 字符串的字面量存储空间通常在只读区，而切片在堆栈申请空间。互相转换会带来一次拷贝消耗。拷贝操作由上面说明的，[]byte(str)、[]rune(str)、string(slice)。 PS：[]byte到string的拷贝消耗不一定是有的，当只需要字面量时（类似C++的右值），不会拷贝内存。

* string与[]byte的区别

&#160;&#160;&#160;&#160;&#160;&#160;&#160;string的应用场景：1、需要进行字符串比较。 2、无法接收nil字符串的场景

&#160;&#160;&#160;&#160;&#160;&#160;&#160;[]byte的应用场景：1、修改字符串的内容。 2、函数返回需要nil值。 3、需要切片操作的场景。

#### 6.常量  

* 声明规则

&#160;&#160;&#160;&#160;&#160;&#160;&#160;常量是一种表达式，无法被声明，在编译期就确定值。声明常量时可以同时携带类型和值。规则：第一项常量必须被赋值，其他项若未被赋值，则复用前面一项的表达式及类型。
<details> 
    <summary>复用</summary>

```go
const {
    num1 = 0
    num2  //没有表达式，复用前一项为0
    num3 time.Duration = 2
}
```
</details>

&#160;
* 常量生成器iota

&#160;&#160;&#160;&#160;&#160;&#160;&#160;常量生成器iota创建一系列相关值，从0开始取值，逐项加一。可以理解为iota随项自增1。

<details> 
    <summary>iota代码</summary>

```go
const {
    num1 = iota //0
    num2 //1
    num3 //2
    num4 //3
}

const {
    left1 = 1 << iota //1
    num2 //2
    num3 //4
    num4 //8
}
```
</details>

## 0x02复杂数据  
#### 1.数组  
* 初始化方式

&#160;&#160;&#160;&#160;&#160;&#160;&#160;数组是Golang中具有固定长度，支持存放0个或多个相同类型元素的连续块。声明和初始化数组时通常有四个方式：1、声明一个数组并设为零值。2、字面量初始化数组。3、自动推导数组长度。4、指定特定元素的值。
<details>
    <summary>数组的四种初始化方法</summary>

```go
//声明但为赋值，默认为零值
var arr_num1 [4]int //  0 0 0 0

//字面量初始化数组
var arr_num2 [4]int = [4]int{1, 2, 3, 4}

//不定长的初始化方式
var arr_num3 = [...]int{1,2,3,4,5} //数组长度自动推导为5

//利用索引赋值
var arr_num4 [5]int = [5]int{0: 5, 4: 1} // 5 0 0 0 1
```
</details>  

&#160;     
* 遍历方式与传参方式  

&#160;&#160;&#160;&#160;&#160;&#160;&#160;**1、遍历方式**  

&#160;&#160;&#160;&#160;&#160;&#160;&#160;Golang中数组和其他具有索引的数据结构一样，通过for-range进行遍历，返回索引index和value。值得注意的是，range只是让index和value对数值进行了值拷贝，操作的是原数组的副本。
<details>
    <summary>for-range遍历</summary>

```go
//字面量初始化数组
var arr_num2 [4]int = [4]int{1, 2, 3, 4}
for idx, val := range arr_num2 {
    //idx每次循环都会自增
    //val会值拷贝对应idx的值，对val做操作不影响原数组
}

```
</details>  

&#160;     
&#160;&#160;&#160;&#160;&#160;&#160;&#160;**2、传参方式**  

&#160;&#160;&#160;&#160;&#160;&#160;&#160;由于Go中所有的传参都是值传递类型。因此函数在调用数组参数时会创建一个副本，这点不同于其他的语言，对副本的修改或读取并不影响原数组。这种值传递的方式在大数组下非常占用资源，可以通过传递数组指针减少资源开销，但指针是引用类型，谨慎对原数组发生修改。
<details>
    <summary>数组传参</summary>

```go
//值传递数组。
func method1(arr [100000]int) {
    //
}
method1(arr) //每次调用会产生巨大的开销

//传递指针避免内存消耗
func method2(arr *[100000]int) {
    //
}
method2(&arr) //值拷贝的消耗减少为一个指针的大小，但要小心原数组被修改

```
</details>  

&#160;     
* 特点  

&#160;&#160;&#160;&#160;&#160;&#160;&#160;1、长度是数组的一部分属性，不能动态变化，在传参时也决定参数类型的唯一性。   2、注重数组内的类型统一，如int和int32不是一个类型。  3、数组在传递时时值拷贝的，内存消耗大。  4 、数组占用内存是连续分配的，因此随机读取速度快。

#### 2.二维数组  
* 声明与赋值

&#160;&#160;&#160;&#160;&#160;&#160;&#160;二维数组的性质与一维数组相同，因此这里只描述二维数组是如何声明、赋值。二维数组的声明必须指定**列数**，同时也支持索引赋值。
<details>
    <summary>二维数组</summary>

```go
var array [4][2]int   //声明一个4行2列的二维数组

array := [4][2]int{ {0,1}, {0,1}, {0,1}, {0,1}} //字面量初始化一个二维数组

array := [4][2]int{0 :{0,1}, 2: {0,1}}    //外层索引赋值

array := [4][2]int{0 :{1: 1}, 2: {0: 1}}    //外层、内层指针索引赋值

array := [...][...]int{ {0,1}, {0,1}, {0,1}, {0,1}} // Wrong,没有指定列数
array := [4][...]int{ {0,1}, {0,1}, {0,1}, {0,1}} // Wrong,没有指定列数
array := [...][2]int{ {0,1}, {0,1}, {0,1}, {0,1}} // 正确
```

</details>  

#### 3.切片  
* slice和数组的关系

&#160;&#160;&#160;&#160;&#160;&#160;&#160;切片表示一个存放相同元素的可变长度动态化序列，可以用来访问底层数组的部分或全部元素，数组是切片的数据支撑。但切片无法像数组一样做同类比较，需要用户手写函数。

* slice数据结构
```go
type slice struct {
	array unsafe.Pointer
	len   int
	cap   int
}
```
&#160;&#160;&#160;&#160;&#160;&#160;&#160;slice有三个属性：指针、长度及容量。指针指向底层数组中slice能访问到的第一个元素地址，且长度不大于容量。  

* slice用法及初始化


&#160;&#160;&#160;&#160;&#160;&#160;&#160;Golang语言允许多个slice对一个底层数组重叠切片,共享底层数组,切片的范围遵循前闭后开的原则。 而切片的初始化则可以通过make函数进行长度和容量的声明。  
&#160;&#160;&#160;&#160;&#160;&#160;&#160;slice也可以像数组一样用字面量或索引进行初始化。  
&#160;&#160;&#160;&#160;&#160;&#160;&#160;slice支持3索引初始化slice[i;j;k]，此时切片长度为j-i，容量为k-i。对于数组而言，比较ij大小和长度比，而对于接收另一个切片，比较ij大小和容量比。
<details>  
<summary>slice初始化</summary>

```go
num := [...]int{1, 2, 3, ,4, 5, 6, 7, 8, 9, 10}

var s1 []int = num[1:6] //切片s1 {2,3,4,5,6}
var s2 []int = num[1:]  //切片s2 {2,3,4,5,6,7,8,9,10}
var s3 []int = num[:6]  //切片s3 {1,2,3,4,5,6}

var newSlice = make([]int, 5)    //只指定长度，不指定容量
var newSlice = make([]int, 5, 10) //指定长度与容量，且长度必须小于容量

var newSlice = []int{1, 2, 3, 4, 5} //字面量初始化
var newSlice = []int{9: 11} //索引初始化，长度为10，最后一个值为9

var newSlice = num[2:4:6] //3索引初始化，长度为4-2=2，容量为6-2=4
```
</details>  


&#160;
* 常用操作

&#160;&#160;&#160;&#160;&#160;&#160;&#160;**1、计算切片的长度和容量:** 对于底层数组容量为k的切片slice[i:j]，切片长度为j-i，容量为k-i。长度值和容量值可以通过函数len(slice)和cap(slice)获得。  
&#160;&#160;&#160;&#160;&#160;&#160;&#160;**2、增加元素append：** 通过表达式slice = append(slice, val)可以在slice的最后追加一个值val，注意返回值和参数值不是同一个切片。append支持可变参数，可追加多个val或slice。

&#160;
* 常见问题

&#160;&#160;&#160;&#160;&#160;&#160;&#160;**1、nil切片和空切片的区别：** slice的零值为nil，也称为nil切片。nil切片可以用于标准库和内置函数。nil切片不等价于空切片，nil切片和空切片最大的区别在于内置指针是否有明确的值：对于nil切片，指针为nil。对于空切片，指针有一个明确的地址。而长度和容量，nil切片和空切片都为0。 nil切片日常使用中要使用make函数进行初始化。
```go
//nil切片的声明
var nil_slice []int

//空切片的声明
empty_slice := []int{}
empty_slice := make([]int, 0)
```
&#160;&#160;&#160;&#160;&#160;&#160;&#160;**2、切片append时，底层发生了什么？** append的底层分情况讨论：①当cap容量足够容纳新值时，调整新切片的范围向后推进一格，并将新值放入该位置，返回新切片。此时新切片和传入的旧切片不一致，但新旧切片的底层数组是一致的。②当cap不足以容纳新值时，底层会开辟一块容量足够的新空间作为底层数组，将旧切片的值复制到新底层数组上，在末尾加入新值，返回新切片。此时新切片和传入的旧切片不一致，且新旧切片的底层数组也是不一致的。  
&#160;&#160;&#160;&#160;&#160;&#160;&#160;**3、开辟新底层数组的规律：** 为了达到提高append的效率和减少内存开销的平衡，当cap小于1000时，新底层数组的容量总是旧底层数组的2倍，当超过1000时，每次扩容为1.25倍。  
&#160;&#160;&#160;&#160;&#160;&#160;&#160;**4、设置长度和容量一样的好处：** 当切片的长度和容量一样时，对其进行append操作会得到新开辟的底层数组，这样后续修改元素避免了对原底层数组的影响。  
&#160;&#160;&#160;&#160;&#160;&#160;&#160;**5、make函数和通过已知变量初始化的区别：**  make函数生成的地址空间只有对slice可见，而已知变量的底层数组同时不仅仅对slice可见。当一个底层数组不再对任一对象可见时，会被GC回收。  
&#160;&#160;&#160;&#160;&#160;&#160;&#160;**6、切片、数组与字符串：** 切片接收数组或另一个切片时，返回一个新切片，而接收一个字符串时，返回的仍是字符串。    
&#160;
* 遍历方式与传参方式

&#160;&#160;&#160;&#160;&#160;&#160;&#160;**1、遍历方式**  

&#160;&#160;&#160;&#160;&#160;&#160;&#160;for-range迭代切片，关键字range会返回两个值：第一个值是当前迭代到的索引位置，第二个值是该位置对应元素的副本，而不是引用。

&#160;&#160;&#160;&#160;&#160;&#160;&#160;**2、传参方式**  

&#160;&#160;&#160;&#160;&#160;&#160;&#160;slice作为函数参数进行传参时通过值拷贝的方法，但由于slice的数据结构较小（24字节），占用内存少并且效率高。但底层数据是和slice中的指针绑定，属于引用类型，因此对slice参数做的底层元素变动会影响原底层数组（append分情况讨论）。

* 底层结构

&#160;&#160;&#160;&#160;&#160;&#160;&#160;slice的数据结构
```go
type slice struct{
    array unsafe.Pointer
    len   int
    cap   int
}
```

#### 4.map 

&#160;&#160;&#160;&#160;&#160;&#160;&#160;Golang中映射用来存储一系列无序的键值对，通过键可以快速地找到值。
* 声明、初始化与读取删改 

&#160;&#160;&#160;&#160;&#160;&#160;&#160;**1、创建与初始化**    

&#160;&#160;&#160;&#160;&#160;&#160;&#160;map的声明与初始化支持make函数，如果不初始化，则map成为nil。另一种方式是用显示字面量初始化。  

&#160;&#160;&#160;&#160;&#160;&#160;&#160;**2、map读取与增删**   

&#160;&#160;&#160;&#160;&#160;&#160;&#160;map的读取通过键名去寻找值，当键在map中不存在时，会返回一个值类型的零值，更安全的做法是用两个返回值。增加一个键值对只需要以修改的形式操作map[key] = val，同样支持根据键名删除值delete(dirc, key)。
<details> 
    <summary>map初始化与读取删改</summary>

```go
var m map[string]int //声明一个映射，遵循 map[keyType]valType
m = make(map[string][int])

//使用字面量初始化
dirc := map[string]int{"first" : 1, "second" : 2}

//修改一个存在的键值对或增加一个键值对
dirc["first"] = 3

//访问一个存在的键值对
temp = dirc["second"]

//删除一个键值对
delete(dirc,"second")

//安全查询map
val, exist := dirc["second"]
if !exist {
    //假设不存在
}

//迭代访问map，是无序的
for k,v := range dirc {
    //访问k，v
}
```
</details>

&#160;
* 底层结构

![image](https://note.youdao.com/yws/api/personal/file/A039219449D2419BB5F0A542C112FA8A?method=download&shareKey=f2d1ab84d4a016eeb0312dc85ad551c7)
&#160;&#160;&#160;&#160;&#160;&#160;&#160;Golang中的map是无序的，原因在于底层使用了散列表而不是红黑树。按图所示，map作为一个数据结构，底层实现了散列表，内部存储了桶数组的地址指针。通过键名哈希获取散列值的低位得到桶数组的具体地址。桶数组内又包括了两个数组，第一个是存放散列值高位的数组，第二个是依照散列值高位存放顺序存放实际键值对的字节数组。注意这边键值不是紧挨着存放的。

* 常见问题

&#160;&#160;&#160;&#160;&#160;&#160;&#160;**1、为什么map必须初始化？**    

&#160;&#160;&#160;&#160;&#160;&#160;&#160;map是引用类型，声明之后需要绑定一个映射表的地址。而nil指针没有指向任何可操作的映射表，视作危险。  

&#160;&#160;&#160;&#160;&#160;&#160;&#160;**2、map的键可以是任意类型吗？**    

&#160;&#160;&#160;&#160;&#160;&#160;&#160;map的键类型不能是引用类型，因为比较地址含无意义。  

&#160;&#160;&#160;&#160;&#160;&#160;&#160;**3、如何对map进行排序？**    

&#160;&#160;&#160;&#160;&#160;&#160;&#160;map本身是无序的。排序方法是先迭代取出所有的键名，排序后再去map中取值。  

* 传参方式

&#160;&#160;&#160;&#160;&#160;&#160;&#160;map的传值方式和切片一致，引用类型传递修改后会影响原值。

* map的底层分析

map的数据结构：
```go
type hmap struct{
    count       int//已存放的映射对数
    B           uint8//Hash桶数组的大小(指数形式)
    buckets     unsafe.Pointer//当前桶数组的地址
    oldbuckets  unsafe.Pointer//旧桶数组的地址，扩容搬迁会用到
}
```
bucket是存放元素的结构体，其底层结构：
```go
type bmap struct {
    tophash  [8]uint8//存放hash值高八位的数组，一个bucket最多存放8个元素
    data     []byte//数据实际存放的切片，为了内存对齐，按切片左边为key扎堆，右边为value扎堆
    overflow *bmap//开链法，当元素超过8个，需要重新申请一个bucket
}
```
由此可以看出map的存储流程：一个bucket最多只能存储8个元素。当得到一个键值时，分析其hash值的低8位，对B取模后得到buckets中具体的一个bucket。然后根据hash值的高8位，和bucket链中的每一个bucket的tophash进行比对。

> 负载因子=映射对数/桶数  
负载因子过高，表示桶少，冲突严重，查询效率低；负载因子过低，说明空间利用率过低。  
但都可以通过rehash解决，负载大于6.5就会rehash。  
扩容：map扩容时，不会一次性将数据从旧的搬迁到新的，而是每次搬迁2个键值对，因此查询时先从新的map再从旧的map查询。



#### 5.结构体  
&#160;&#160;&#160;&#160;&#160;&#160;&#160;结构体是一类包含0种或多种任意类型的命名变量组合在一起的聚合数据类型。
* 定义、初始化与操作

&#160;&#160;&#160;&#160;&#160;&#160;&#160;**1、定义：** 指明结构体包含的类型和变量名。需要注意的是，由于Go可见性设计的特殊性，当结构名首字母为小写时，说明该结构体对外不可见，同理变量亦是。  

&#160;&#160;&#160;&#160;&#160;&#160;&#160;**2、初始化：** 初始化需要字面量指明结构体包含的类型和变量名，若没有初始化步骤，结构体的零值就会由成员变量的零值来组成。
<details> 
    <summary>定义与初始化</summary>

```go
//定义一个对外不可见的结构体
type user struct{
    
}

//定义对外可见的结构体
type User struct{
    Score int   //Score对外可见
    name string //name对外不可见
}

//声明一个结构体，其为零值
var stu User //stu保持零值，内部成员变量分别是对应类型的零值

//字面量初始化
//显式
stu := User{
    Score: 100,
    name: "Lisa",
}
//隐式
stu := User{100, "Lisa"}
```
</details>

&#160;  
&#160;&#160;&#160;&#160;&#160;&#160;&#160;**3、嵌套结构体与匿名成员：** Go中结构体支持嵌套，同样这是继承的主要实现手段之一，在结构体内部放置一个匿名成员，实现复用。
<details> 
    <summary>嵌套结构体与匿名成员</summary>

```go
type Point struct {
    X, Y int
}

type Circle struct {
    Point
    Radious int
}

type Wheel struct {
    Circle
    Spokes int
}

//带匿名成员的初始化方法两种
w := Wheel{Circle{Point{1,2}, 1}, 10} //方法一，不用变量名
w := Wheel{
    Circle: Circle{
    Point: Point{1,2},
    1
    },
    10
} //方法二，带变量名

```
</details>

&#160;  
* 传参方式

&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct的传值方式是值拷贝出的新副本，对于大型的结构体效率非常低，但也要谨慎使用指针，修改副本的引用类型指向值或用结构体的指针会影响原值，因为指向的是同一块区域。

* 常见问题 

&#160;&#160;&#160;&#160;&#160;&#160;&#160;**1、用值和指针访问结构体变量的区别：** 在Go语言中，经常能看到这一段使用方式。之所以能用指针像值一样直接访问变量名，原因是底层对操作进行优化，防止因为忘记增加取值符而引起错误。具体来说，当运行到这一步，编译器发现用了指针而不是值，则ptr_stu会自动转为*ptr_stu。
```go
ptr_stu = &Stu{1, 20}
ptr_stu.Score //等同于(*ptr_stu).Score
ptr_stu.Name //等同于(*ptr_stu).Name
```

&#160;&#160;&#160;&#160;&#160;&#160;&#160;**2、关于结构体的工厂模式:** 前面提到当结构体名为小写时，无法被外部文件所使用。但其他文件需要使用该类型实例时，可以用工厂模式。工厂模式算是解决没有构造函数的弊端，也能够安全地让外部文件访问指定内部元素。
<details> 
    <summary>工厂模式</summary>

```go
type struct student {
    name string
    score int
}

//工厂函数
func NewObject(name string, score int) *student{
    return &student{name, score}
}

//访问结构体内部指定值
func GetName(stu *student) string{
    return stu.name
}
```
</details>

&#160;  
&#160;&#160;&#160;&#160;&#160;&#160;&#160;**3、关于嵌套结构体的访问流程:** 在嵌套的结构体下，访问成员变量的流程先从最外层开始寻找，找到变量名就返回，找不到变量名就递归进入匿名成员继续寻找。
```go
//若只有一个obj
stu.A.B.obj等同于stu.obj
但若A中和B中都有obj，则不能用简略表达
```
&#160;&#160;&#160;&#160;&#160;&#160;&#160;**4、结构体中的引用类型成员变量声明:** 结构体内如果有切片或者指针，需要先make后才能使用。成员变量是连续存放的，但成员变量指向的内容不一定是连续存放的。



#### 6.JSON  
&#160;&#160;&#160;&#160;&#160;&#160;&#160;JSON是一种发送和接收格式化的标准，是JavaScript的Unicode编码，包含所有的基本数据类型和复杂数据类型，因此JSON和Go中的对象结构体能够互相转换，并且在网络中用的较为频繁。
* 结构体与json  

&#160;&#160;&#160;&#160;&#160;&#160;&#160;**1、纽带：成员标签定义**  
&#160;&#160;&#160;&#160;&#160;&#160;&#160;结构体中可以定义结构体在序列化成json字符串时，将成员变量名映射为``符号中的名字。以下列代码为例，那么后端的函数中，Student成员会以Name进行交流，对应http返回的json中的name变量。如果没有成员标签定义，那么解析json格式时，会按照json的变量名去解析，如果前后变量名对不上，则无法写入，那么backend的结构体中会存在零值。omitempty是额外约束，表示如果这个成员是置零或为空，则不输出到成员变量中
```go
type Student {
    Name string `json:"name"`//冒号后面不能有空格
    Score int `json:"grade,omitempty"`
}
```
&#160;&#160;&#160;&#160;&#160;&#160;&#160;**2、数据格式**  
&#160;&#160;&#160;&#160;&#160;&#160;&#160;数据格式分为前端返回的json数据格式和后端接收的结构体数据格式。由于传回的json格式frontend_type是不能改变的，本地需要适配一个相同数据类型的结构体backend_type，才能完成数据传输。当然也可以自定义backend的数据格式，选择自己需要的那一部分作为结构体，

* 编码与解码

&#160;&#160;&#160;&#160;&#160;&#160;&#160;编码是指在后端本地将结构体编写成前端能接收的json文件格式。解码是指后端本地接收前端的json文件，变成结构体格式的变量。这里编码与解码各有两种不同的方式。  
&#160;&#160;&#160;&#160;&#160;&#160;&#160;**1、解码方式流处理：解码器**  
&#160;&#160;&#160;&#160;&#160;&#160;&#160;解码器是指从流数据中直接解码，应用于http或socket中较多，不需要后端人员先获取JSON字符串。
<details> 
    <summary>解码器</summary>

```go
package main

import (
	"encoding/json"
	"fmt"
	"os"
)

type Student struct {
	Name  string `json:"newName"`
	Score int    `json:"newScore"`
}

func main() {
	var stu Student
	//读取文件流和解码器
	file, _ := os.Open("students.json")
	json.NewDecoder(file).Decode(&stu)//必须传入地址
	defer file.Close()
	fmt.Print(stu)
}
//打印内容：{Lisa 100}
```
</details>   
&#160;   

&#160;&#160;&#160;&#160;&#160;&#160;&#160;**2、解码方式字符串处理：反序列化**  
&#160;&#160;&#160;&#160;&#160;&#160;&#160;反序列化是指假设后端人员已经获取了json格式的string字符串，转化成结构体变量。但由于函数只与[]byte交互，因此string需要先转为字节数组。
<details> 
    <summary>反序列化</summary>

```go
package main

import (
	"encoding/json"
	"fmt"
)

type Student struct {
	Name  string `json:"newName"`
	Score int    `json:"newScore"`
}

func main() {
	data := `{"newName":"Lisa","newScore":100}`
	var stu Student
	json.Unmarshal([]byte(data), &stu)
	fmt.Print(stu)
}
输出：{Lisa 100}

```
</details>   
&#160;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;**3、编码方式流处理：编码器**  
&#160;&#160;&#160;&#160;&#160;&#160;&#160;编码器是将结构对象编码成JSON数据，输送到流数据中。
<details> 
    <summary>编码器</summary>

```go
package main

import (
	"encoding/json"
	"os"
)

type Student struct {
	Name  string `json:"newName"`
	Score int    `json:"newScore"`
}

func main() {
	stu := Student{
		Name:  "Lisa",
		Score: 100,
	}
    //文件流和编码器
	file, _ := os.Create("students.json")
	json.NewEncoder(file).Encode(&stu)//传入地址
}
//文件内容：{"newName":"Lisa","newScore":100}
```
</details>   
&#160;


&#160;&#160;&#160;&#160;&#160;&#160;&#160;**4、编码方式字符串处理：序列化**  
&#160;&#160;&#160;&#160;&#160;&#160;&#160;序列化是指将结构对象编码成[]byte数组，若要输出string，需要再转换一下。

<details> 
    <summary>序列化</summary>

```go
package main

import (
	"encoding/json"
	"fmt"
)

type Student struct {
	Name  string `json:"newName"`
	Score int    `json:"newScore"`
}

func main() {
	stu := Student{
		Name:  "Lisa",
		Score: 100,
	}
	var data []byte

	data, err := json.Marshal(&stu)//序列化函数，取地址
	if err != nil {
		return
	}
	fmt.Print(string(data))
}
打印：{"newName":"Lisa","newScore":100}
```
</details>   

## 0x03类型断言  
#### 1. 类型与类型断言
* 类型  

&#160;&#160;&#160;&#160;&#160;&#160;&#160;Go中的类型分为静态类型和动态类型，静态类型是指在声明或初始化时确定下来的，肉眼可见的。动态类型则是指编译器在编译时见到的类型。举个例子，空接口interface{}能接收到任意类型的变量，实际类型为动态类型。  
&#160;&#160;&#160;&#160;&#160;&#160;&#160;另外Golang中对类型区分很大，像rune和int32被视作两个类型。
```go
var a interface{} //a的静态类型为interface{}
a = int(1)        //a的动态类型为int
a = string("123") //a的动态类型为string
```
* 类型断言  

&#160;&#160;&#160;&#160;&#160;&#160;&#160;类型断言是作用在接口上的操作，通常表示方法为x.(T)，用于检查x是否为nil或i的动态类型。如果满足，断言成功，返回T类型的动态值。如果失败，抛出Panic。通常类型断言有三种情况需要讨论。  
&#160;&#160;&#160;&#160;&#160;&#160;&#160;**1、若T为具体类型：** 当T为具体类型时，x.(T)的作用是检查x的动态类型是否为T类型，若成功，取出X的动态类型和动态值，可以赋给临时变量。用ok语句查询更安全。
<details> 
    <summary>T为具体类型</summary>

```go
package main

import (
	"fmt"
)
//定义了两个接口
type reader interface {
	read()
}
type writer interface {
	write()
}
//Stu完全实现两个接口
func (s Stu) read() {
	fmt.Println("read")
}

func (s Stu) write() {
	fmt.Println("write")
}
//Tea实现read接口
func (s Tea) read() {
	fmt.Println("read")
}
//Teb完全write两个接口
func (s Teb) write() {
	fmt.Println("write")
}

type Stu struct {
}

type Tea struct {
}

type Teb struct {
}

func main() {

	var w reader //w的静态类型为reader
	w = Stu{}   //w的动态类型为Stu
	r := w.(Stu) //判断w的动态类型是否为Stu，将动态同值一并赋给r，并作为r的静态类型。
	//ok语句查询更安全
	// r, ok := w.(Stu) 断言成功，ok为true，r为值。断言失败，ok为false，r为断言类型的零值。
	r = Tea{} //Wrong，r的静态类型和动态类型都是Stu
	fmt.Printf("%T, %T", r, w) //输出main.Stu, main.Stu
}

```
</details>

&#160;  
&#160;&#160;&#160;&#160;&#160;&#160;&#160;**2、若T为接口类型：** 当T为接口类型时，x.(T)的作用是检查x的动态类型是否满足T接口（实现T的所有方法），若成功，保留X的的动态值和动态类型，而新变量的静态类型变为T，动态类型和值与x一致。
<details> 
    <summary>T为接口类型</summary>

```go
package main

import (
	"fmt"
)
//定义了两个接口
type reader interface {
	read()
}
type writer interface {
	write()
}
//Stu完全实现两个接口
func (s Stu) read() {
	fmt.Println("read")
}

func (s Stu) write() {
	fmt.Println("write")
}
//Tea实现read
func (s Tea) read() {
	fmt.Println("read")
}
//Teb实现write
func (s Teb) write() {
	fmt.Println("write")
}

type Stu struct {
}

type Tea struct {
}

type Teb struct {
}

func main() {

	var w reader  //w的静态类型为reader
	w = Stu{}     //动态类型为Stu
	r := w.(writer)  //w保留原类型，w实现过writer接口，r的动态类型和值与w保持一致，都为Stu，但静态类型为writer
	r = Teb{} //只实现writer的Teb结构体可以赋值给r
	w = Tea{} //只实现writer的Tea结构体可以赋值给w
	fmt.Printf("%T, %T", r, w)//打印结果用的是动态类型，输出：main.Teb, main.Tea
}

```
</details>

&#160;  
&#160;&#160;&#160;&#160;&#160;&#160;&#160;**3、若x为nil：** 当x为nil时，直接返回失败。
<details> 
    <summary>x为nil</summary>

```go
package main

import (
	"fmt"
)

type reader interface {
	read()
}
type writer interface {
	write()
}

func (s Stu) read() {
	fmt.Println("read")
}

func (s Stu) write() {
	fmt.Println("write")
}

func (s Tea) read() {
	fmt.Println("read")
}

func (s Teb) write() {
	fmt.Println("write")
}

type Stu struct {
}

type Tea struct {
}

type Teb struct {
}

func main() {

	var w reader  //声明w未赋值，此时w为nil
	r := w.(reader) //会抛出Panic，w为nil
	//panic: interface conversion: interface is nil, not main.reader
	fmt.Printf("%T, %T", r, w)
}

```
</details>

#### 2. 类型分支
* x.(type) 

&#160;&#160;&#160;&#160;&#160;&#160;&#160;类型分支的分支判定基于接口的动态类型，nil分支只有当x为nil才满足，default分支只有当其他分支都没满足时才运行。分支的顺序是有讲究的，可能x.(type)会满足多个分支，当一个分支满足后就立即执行并退出。

<details>
    <summary>x.(type)用法</summary>

```go
switch x.(type) {
	case nil:
		//do nil
	case int:
		//do int
	case float32:
		//do float32
	//....
	default:
		//do default
	}
```
</details>