---
layout: post
title: Go知识点大梳理(三)函数方法接口
category: Go语言
keywords: Go Go接口 Go函数 Go方法
tags: Go
---



# Go知识点大梳理(三)函数、方法、接口

## 0x00前言
++在Go中，函数、方法、接口三者是最相似的，因为它们同属调用者。函数视作调用0个或多个参数，进而对参数处理，它不属于任何对象。方法的功能和函数一样，但归属于某个对象,前置条件主体是用户自定义的。接口是方法声明的集合，当某个对象实现了接口中的所有方法时，称为该对象就是接口。++

## 0x01函数 
#### 1.函数语法与函数签名  
&#160;&#160;&#160;&#160;&#160;&#160;&#160;函数声明包含一个名字、一个形参列表、一个可选的返回值列表及函数体。在写法上可以加入空白标识符表示用不到的参数。
```go
func name(param-list) (return-list) {
    //function body
}
```
&#160;&#160;&#160;&#160;&#160;&#160;&#160;函数签名就是函数的类型，由函数参数列表和返回值列表组成。Go没有默认参数值。

#### 2.函数调用机制与实参
&#160;&#160;&#160;&#160;&#160;&#160;&#160;函数调用机制：在调用一个函数时，会在栈区分配一个新空间，编译器会进行优化将其与其他栈空间独立开。每个函数对应的栈中，数据是函数局部空间的。程度执行完成后，销毁栈空间。
&#160;&#160;&#160;&#160;&#160;&#160;&#160;实参传递的方式是值拷贝，因此函数内的局部变量是实参的副本。对于值类型，改变形参变量不会影响到实参；但对于引用类型，实参和形参本质上是共享空间。
#### 3.函数变量 
&#160;&#160;&#160;&#160;&#160;&#160;&#160;函数也可以是一个变量，作为形参或返回值存在于其他函数中,未被赋值的函数变量是一个nil。
```go
func add(x int) int {
    return x + 1;
}
var f func(int) int //此时是一个nil
f = add  
y := f(1) //y=2

```
#### 4.匿名函数与闭包 
&#160;&#160;&#160;&#160;&#160;&#160;&#160;匿名函数是指只写明函数签名和表达式的函数，但不写明函数名。匿名函数设计的初衷是不会显式地通过函数名去调用，常用于赋值给函数变量或者闭包。   
```go
func A(x int) int {
	return func() int {//匿名函数
		return x
	}()
}
```
&#160;&#160;&#160;&#160;&#160;&#160;&#160;闭包是指函数和相关引用变量组合起来的整体。返回的匿名函数和匿名函数外的变量共同形成闭包函数环境。多次调用函数时，环境变量不会每次都初始化。闭包具有记忆性，在某些场景下可以只需导入一次。
<details>
    <summary>闭包案例</summary>

```go
func squares() func() int {
    var x int = 2
    return func () int {
        x++
        return x * x
    }
}
```
</details>    

#### 5.延迟函数  
&#160;&#160;&#160;&#160;&#160;&#160;&#160;defer函数是Go中的一个延时机制，用于函数结束前的最后一个动作。保证即使在崩溃状态下，defer语句正常执行，常用于释放资源语句。defer不是立马执行的，而是在函数完成前最后运行，但环境上下文仍是当时的。局部函数中可以由多个defer，运行顺序为倒序。
* 三大特性

&#160;&#160;&#160;&#160;&#160;&#160;&#160;defer语句具有函数局部性、环境不变性、自下而上性。

* 底层剖析

&#160;&#160;&#160;&#160;&#160;&#160;&#160;当程序顺序运行到defer处时，保存当时的上下文环境，将defer代码依次压入栈中，等到该函数结束前，又从栈中依次弹出defer代码运行。

<details>
    <summary>解锁的延迟函数用例</summary>

```go
var mu sync.Mutex
var m = make(map[string] int)
func lookup(key string) {
    mu.Lock()
    defer mu.Unlock()
    return m[key]
}
```
</details>  

#### 6.变长函数 
&#160;&#160;&#160;&#160;&#160;&#160;&#160;变长函数是指在被调用时，该函数可以有可变的参数个数。具体方式为在声明函数时，在最后的类型名称之前使用省略号...,表示为一个变长函数。   
&#160;&#160;&#160;&#160;&#160;&#160;&#160;变长函数的调用方法也可以传入一个slice，具体方式是在调用语句的slice变量后加入...
<details>
    <summary>变长函数示例</summary>

```go
//声明一个变长函数
func sum(vals ...int) int {
    total := 0
    for _, v := range vals {
        total += v
    }
    return total
}

sum(1,2,3) //普通调用

vals := []int{1,2,3}
sum(vals...) //slice调用

```
</details>  

## 0x02方法  
#### 1.条件及声明方式
&#160;&#160;&#160;&#160;&#160;&#160;&#160;方法只能作用于用户自定义的类型上，对于基础类型无作用。方法的声明和普通函数的声明相似，只是在函数名前加了接收者的类型。方法无法单独调用，只能由特定的对象调用。

```go
//方法的声明方式
func (r receiver)Method(param-list) (return-list) {
    
}
```
#### 2.接收者的传参方式
&#160;&#160;&#160;&#160;&#160;&#160;&#160;接收者的传参方式和函数一致，为值拷贝方式。因此对接收者副本的任意修改都不会影响原值，除非传递的是引用类型，共享底层数据。
<details>
    <summary>接收者的传参方式实例</summary>

```go
//接收者是值类型
type Stu struct {
	Score int
}
func (s Stu) ResetScore() {
	s.Score = 2
}

func main() {
	var stu = Stu{100}
	fmt.Println(stu.Score)
	stu.ResetScore()
	fmt.Println(stu.Score) //输出100 100，原值数据未变动
}

//接收者是引用类型
type Stu struct {
	Score int
}
func (s *Stu) ResetScore() {
	s.Score = 2
}

func main() {
	var stu = Stu{100}
	fmt.Println(stu.Score)
	stu.ResetScore()
	fmt.Println(stu.Score) //输出100 2，原值数据变动
}
```
</details>

#### 3.接收者的实参形式和形参形式
&#160;&#160;&#160;&#160;&#160;&#160;&#160;方法的接收者可以是值类型也可以是指针类型，但本身是指针形式的值类型是无法通过编译的。在某些特殊的函数里，nil是可以作为指针对象调用方法的。
```go
type PtrReceiver *reveiver

func (r *receiver)Method(param-list) (return-list) {
    //可以通过编译
}

func (r PtrReceiver)Method(param-list) (return-list) {
    //无法通过编译
}
```
* 简化的实参形式和形参形式

&#160;&#160;&#160;&#160;&#160;&#160;&#160;Go底层对接收者做了部分优化，允许接收者的指针类型和值类型进行混用。  
&#160;&#160;&#160;&#160;&#160;&#160;&#160;**1、对于形参接收者为值类型，实参为指针类型的情况**  
&#160;&#160;&#160;&#160;&#160;&#160;&#160;在编译器进行解析时，如果传入的实参是指针类型，但形参是值类型，会自动插入一个隐式的*来解引用。ptrstu.ResetScore()隐式转换为(*ptrstu).ResetScore()。  
```go
type Stu struct {
	Score int
}

func (s Stu) ResetScore() { //值类型声明的方法
	s.Score = 2
}

func main() {
	var ptrstu = &Stu{100} //ptrstu是一个指针
	fmt.Println(ptrstu.Score) //打印100
	ptrstu.ResetScore() //用指针去调用值类型声明的方法
	fmt.Println(ptrstu.Score) //打印：100
}
```

&#160;&#160;&#160;&#160;&#160;&#160;&#160;**2、对于形参接收者为指针类型，实参为值类型的情况**  
&#160;&#160;&#160;&#160;&#160;&#160;&#160;在编译器进行解析时，如果传入的实参是值类型，但形参是指针类型，会自动插入一个隐式的&来寻找值的地址。stu.ResetScore()隐式转换为(&ptrstu).ResetScore()。
```go
type Stu struct {
	Score int
}

func (s *Stu) ResetScore() { //指针类型声明的方法
	s.Score = 2
}

func main() {
	var stu = Stu{100} //ptrstu是一个值类型
	fmt.Println(stu.Score) //打印100
	stu.ResetScore() //用值去调用指针类型声明的方法
	fmt.Println(stu.Score) //打印：2
}
```
&#160;&#160;&#160;&#160;&#160;&#160;&#160;ps：当形参为指针类型时，临时变量（取不到地址）是无法 使用方法的，但未赋值的值变量可以（使用了默认值）。
```go
func (s *Stu) ResetScore() { //指针类型声明的方法
	s.Score = 2
}

func main() {
	Stu{}.ResetScore() //错误的，临时变量无法取到地址
	var tmp Stu
	tmp.ResetScore() //可以
}
```
&#160;&#160;&#160;&#160;&#160;&#160;&#160;**3、总结**  
&#160;&#160;&#160;&#160;&#160;&#160;&#160;传入是值拷贝还是地址拷贝在调用者的层面无法被看出，只有从方法绑定的接收者类型才能确定。在对象(注意不是接口)调用方法的形式上，值类型和引用类型是可以相互转换的，原因在于底层机制的优化。但这条规律不适用于接口。
#### 4.结构体内嵌与方法
&#160;&#160;&#160;&#160;&#160;&#160;&#160;对于有匿名成员的内嵌结构体，其匿名成员实现的方法，(如果外层没有对同样的方法进行实现)对于外层结构体同样使用，但匿名成员在参数列时表，需要外部结构体完全指明到匿名成员。
```go
package main

import (
	"fmt"
)
//正方形结构体，包含了长方形
type square struct {
	rectangle
	Name string
}
//长方形结构体
type rectangle struct {
	width, height int
}
//接收者为长方形
func (r rectangle) Area() int {
	return r.height * r.width
}
//形参为长方形的代码
func getArea(rec rectangle) int {
	return rec.height * rec.width
}

func main() {
	sq := square{
		rectangle: rectangle{2, 2},
		Name:      "square",
	}
	fmt.Println(sq.Area()) //输出4， 表明外部结构体可以调用内嵌者的方法
    fmt.Println(getArea((sq.rectangle))) //必须指明到内嵌结构体
}
```
&#160;&#160;&#160;&#160;&#160;&#160;&#160;其底层原理为，对于每个内嵌结构体的方法，外层结构体都会将接收者改为自身，声明出属于自身的方法，同时保留内嵌结构体的方法。

#### 5.方法变量与方法表达式
* 方法变量

&#160;&#160;&#160;&#160;&#160;&#160;&#160;同函数有函数变量，方法也有方法变量。方法变量是一个函数，把方法绑定到一个明确的接收者上，调用时只需要提供实参即可。
```go
p := Point{1,2}
q := Point{3,4}
methodVariable := p.Distance() //以Point为接收者的方法，需要具体的变量
methodVariable(q) //只需要实参就可以调用
```

* 方法表达式

&#160;&#160;&#160;&#160;&#160;&#160;&#160;方法表达式的赋值是由类型绑定的，和方法变量的区别在于，不需要具体的变量，调用的时候将接收者放在第一变量的位置。
```go
p := Point{1,2}
q := Point{3,4}
methodExpression := Point.Distance() //以Point为接收者的方法，不需要具体的变量
methodExpression(p,q) //需要接收者，放在第一位，也需要其他实参
```

#### 6.接收者的选择：何时用值类型，何时用指针类型？
&#160;&#160;&#160;&#160;&#160;&#160;&#160;①看方法体，若方法体的目的是修改接收者本身或上下游共享的话，传指针，否则视作保护内部结构，用值类型。
&#160;&#160;&#160;&#160;&#160;&#160;&#160;②携带引用类型的接收者一律传值。

## 0x03接口 

&#160;&#160;&#160;&#160;&#160;&#160;&#160;在Go中，接口是一套行为约定的抽象类型，定义了一套未被实现的方法，同时也是一个引用类型。如果某个类型想要实现这个接口，就要实现这个接口的所有方法。
#### 1.接口声明
&#160;&#160;&#160;&#160;&#160;&#160;&#160;接口的声明通常有三种方法：组装、混合、全声明,结构都是以type InterfaceName Interface开头,且内部方法只需写明方法的签名（无接收者）。
<details>
    <summary>接口声明</summary>

```go
//全声明
type Writer Interface {
    Write() 
}
type Reader Interface {
    Read() 
}

//混合声明
type ReadWriter Interface {
    Writer
    Read()
}

//组合
type ReadWriter Interface {
    Writer
    Reader
}
```
</details>

#### 2.内部结构
&#160;&#160;&#160;&#160;&#160;&#160;&#160;接口能够存储对象，值的类型（用户自定义的类型）被称作动态类型，具体的值称为动态值。接口在被赋值后，内部是两个字长的数据结构，第一个字长为指向内部表iTable的指针，第二个字长为指向所存储值的指针。itable包括了所存储值的类型和方法集。
![image](https://note.youdao.com/yws/api/personal/file/3F494F7900A5493C9121DA9A5FEF4392?method=download&shareKey=7f09c2f8ba242c492aba15d83aaf9ffe)
![image](https://note.youdao.com/yws/api/personal/file/A728C6896C3A497D83A27D25B66D5E59?method=download&shareKey=16b942503fa1563a80619151efcc9c21)

<details>
    <summary>静态类型与动态类型</summary>

```go
package main

import (
	"fmt"
)

type Get interface {
	getscore() int
}

type Student struct {
	score int
}

func (s Student) getscore() int {
	return s.score
}

func main() {
	var g Get //声明g是一个接口,Get是它的静态类型，未赋值无动态类型
	stu := Student{}   //初始化一个Student
	g = stu        //g的动态类型变为Student，动态值为stu
	fmt.Print(g.getscore()) //调用stu类型的具体方法getscore

}

```
</details>


#### 3.空接口的妙用
&#160;&#160;&#160;&#160;&#160;&#160;&#160;Go中有个神奇的空接口，可以接纳一切类型的数据。

#### 4.接口方法接收者，值类型与指针类型如何选择？
&#160;&#160;&#160;&#160;&#160;&#160;&#160;与方法的规定不同，接口中的方法集规定：接口中对于接收者为指针类型的方法，该接口只能被指针类型的变量赋值；而接口中对于接收者为值类型的方法，该接口可以被指针类型的变量赋值，也可以被值类型的变量赋值。  
<details>
    <summary>接收者：值类型和指针类型</summary>

```go
//修改上述代码，值类型和值类型肯定能对上，同理指针类型亦是
//观察方法的接收者为指针，接口的赋值为值
func (s *Student) getscore() int { //方法为指针
	return s.score
}

func main() {
	var g Get
	stu := Student{}   
	g = stu  //赋值为值，编译失败
	fmt.Print(g.getscore())

}

//观察方法的接收者为值，接口的赋值为指针
func (s Student) getscore() int { //方法为值
	return s.score
}

func main() {
	var g Get
	stu := &Student{} 
	g = stu //赋值为指针类型，编译成功
	fmt.Print(g.getscore())

}

```
</details>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;原因在于编译器不能总是自动获取到一个值的地址，比如临时变量的地址。

#### 5.接口的特点
&#160;&#160;&#160;&#160;&#160;&#160;&#160;1、接口内部所有的方法都是未实现的  
&#160;&#160;&#160;&#160;&#160;&#160;&#160;2、只要是自定义类型，都可以实现接口，即type声明的类型  
&#160;&#160;&#160;&#160;&#160;&#160;&#160;3、接口本身是一个引用类型，没有初始化则为nil  
&#160;&#160;&#160;&#160;&#160;&#160;&#160;4、空接口interface{}没有任何方法，所有类型都实现空接口  
&#160;&#160;&#160;&#160;&#160;&#160;&#160;5、接口能够实现继承关系，内部类型实现的接口自动提升到外部。  
&#160;&#160;&#160;&#160;&#160;&#160;&#160;**6、总而言之,结构体是用于基本数据无法表示的情景，而接口是规定多个自定义类型相似的行为，只是制定标准而不是实现。**


